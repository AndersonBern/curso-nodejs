NODEJS

O nodeJS é um programa que lê e interpreta JavaScript na sua 
maquina. Funciona em módulos e pacotes.


NO TERMINAL(Crtl + '')

cls: Para limpar o terminal.

node nomeDoArquivo.js: Para executar o seu código JS.


PALAVRAS-CHAVE

* Globais: Funciona em qualquer parte do escopo do meu projeto.

	- process : Objeto que fornece unformações sobre o 
		    processo que está sendo executado.

	- console : Semelhante ao navegador. Fornece Retorno.


* Pseudo-Globais: Funciona no escopo do arquivo que está sendo 
  		  executado.

	- module : Objeto que pertence ao sistema de modulos 
		   do node.

	- __filename : A palavra-chave que contém o caminho 
		       do arquivo de execução atual. 

	- __dirname : A palavra-chave que contém o caminho para 
		      o diretório raiz atual.

	- require() : Função que permite incluir módulos válidos.



MÓDULOS / PACOTES

1 - Módulos incorporados -> Built-in Modules (NATIVOS).

2 - Módulos Locais -> Local Modules (QUE A GENTE CONSTRÓI).

3 - Módulos de Terceiros -> Third Party Modules 
   (QUE OUTROS FIZERAM).


PARA FAZER UM REQUERIMENTO DE MODULOS LOCAIS:

1- Você vai criar um código com algo como uma função, por exemplo.
   E você vai exportar essa função em MODULO como um OBJETO{}:

	ex.: 
		function somar(a, b) {
    			return a + b;
		}

		module.exports = {somar};

	OBS.: SEMPRE EXPORTE A FUNÇÃO COMO UM OBJETO.

3- Depois de exportar o modulo com a função, EM OUTRO ARQUIVO,
   você vai fazer o REQUERIMENTO deste modulo.

	ex.: const calculo = require('localDoArquivo.js');

	OBS.: SEMPRE FAÇA O REQUERIMENTO DENTRO DE UMA 
	      VARIAVEL OU CONSTANTE. 
	      
4- Para chamar a função do modulo que foi requerido use:
   - nomeDaVariavel.nomeDaFunção().

	ex.: calculo.somar(5, 2).

4- Pronto, você fez um requerimento de uma função que estava 
   em outro arquivo.




MÉTODO MAIS MODERNO PARA EXPORTAR E IMPORTAR MODULOS

* export {objeto}: Para exportar o modulo.

* import {objeto} from './localDoArquivo.js' : Para importar o 
					     modulo.


PARA EXPORTAR O OBJETO {CALCULADORA}:

ex.: const calculadora = {
    	somar: function(a, b){
        return a + b;
    	}
     }

     export {calculadora};

	

PARA IMPORTAR O MODULO {CALCULADORA}:

ex.: import {calculadora} from './modules/calculadora.js';

OBS.: Você pode importar quantos modulos quiser dentro das chaves. 


PARA CHAMAR O MODULO {CALCULADORA}:

ex.: console.log(calculadora.somar(5, 2));



MODULOS NATIVOS

http : Modulo de WEB SERVER.

    * PARA CRIAR UM SERVER:

	1- Importa e faz a requisição do modulo 'http'.

		- const http = require('http');


	2- É necessário dar 2 parametros para o servidor:

		- HOSTNAME(Local onde o servidor é hospedado).

		- PORTA(é a porta de acesso, para conceder a 
	   	  permissão para acessar o servidor).


	3- Cria o HOSTNAME.

		- const hostname = '127.0.0.1';

		O endereço de IP: 127.0.0.1 é o endereço padrão 
		para uma maquina local. Também pode se usar o 
		valor: 'localhost'.


	4- Cria a PORTA.

		- const PORT = process.env.PORT || 3000;

		Por padrão cria-se a constante/variável em letras
		maiúculas.

		* process.env :
		É um objeto que contém as variáveis de ambiente do
		sistema em que o Node.js está sendo executado. 
		
		* .PORT :	
		Refere-se a uma constante/variável de ambiente que
		define o número da porta que um servidor ou 
		aplicação web deve usar para ouvir conexões de 
		rede.

		* || 3000 : 
		Refere-se a uma porta padrão caso a porta definida
		anteriormente não funcione. Lê-se: OU porta 3000.

	5- Cria o SERVIDOR.

		- const server = http.createServer(
    			function(req, res){
        
    			}
		  );

		* http.createServer() :
		Com o modulo 'http' utilizamos o método 
		'.createServer()' para criar o servidor, e dentro
		dos parenteses definimos oque vai acontecer quando
		o servidor for chamado.

		* function(req, res){} :
		A função que vai ser executada. e os parametros:
		'req' = REQUISIÇÃO, 'res' = RESPOSTA. 
		Para determinar o que vai receber como requisição
		do servidor e a resposta do servidor.

	6- inicializar o SERVIDOR.

		- server.listen(PORT, hostname, function(){
    			console.log(`Servidor rodando em: 
			http//:${hostname}:${PORT}`)
		  })

		* server.listen() :
		Para inicializar o servidor. E dentro do método
		vão 3 parametros: 
			-> PORTA;
			-> HOSTNAME;
			-> FUNÇÃO DE RETORNO.
		(Para determinar oq vai acontecer quando SERVER 
		for iniciado.)
		Que no caso vai ser um 'console.log'.


	PARA ADICIONAR UMA RESPOSTA NO SERVIDOR:

	ex.: const server = http.createServer(
     		function(req, res){
        		res.statusCode = 200;
    		}
     	     );

	O parametro 'res' é para a resposta. E com o metodo '.statusCode'
	damos um código que pode significar algumas coisas como:
	
		- res.statusCode = 200; : OK.

		- res.statusCode = 201; : Created, Para 
					  requisições tipo POST.

		- res.statusCode = 404; : NOT FOUND.


	PARA RESPONDER COM UM CABEÇALHO:

	ex.: res.setHeader('Content-type', 'text/html; 
	     charset= utf-8');
     	     res.end('<h1>Hello world!</h1>');
	
		.setHeader(): Para responder com um cabeçalho.
		E os paremetros:
			- 1: Tipo do conteúdo.
			- 2: Formato do conteúdo.
		Neste caso o tipo de conteúdo foi 'texto/HTML' e 
		'charset' para ler caracteres com acentos.

		* .end(): É um método que finaliza uma requisição
			  HTTP. Neste caso retornou um <H1>.


	PARA DAR RESPOSTAS DIFERENTES EM URL'S DIFERENTES:

	ex.: let url = req.url;

     	if(url === '/'){
     		res.statusCode = 200;
        	res.setHeader('Content-type', 'text/html');
        	res.end('<h1>Hello world!</h1>');
     	}
     	if (url ==='/sobre'){
         	res.statusCode = 200;
         	res.setHeader('Content-type', 'text/html');
         	res.end('<h1>Página SOBRE!</h1>');
     	}


	* let url = req.url : Para dar o valor da URL a variavel.

	* if(url === '/') : Se a URL for igual a '/' 
	   (PAGINA INICIAL), vai dar a resposta.

	* if (url ==='/sobre') : Se a URL for igual a '/sobre',
	  vai dar a resposta.


PARA NÃO SER NECESSÁRIO FICAR REINICIANDO O SERVIDOR TODA VEZ QUE
FIZER UMA ALTERAÇÃO:

- nodemon nomeDoArquivo(NO TERMINAL) : Assim vai ser o servidor 
				       ser atualizado 
				       automaticamente.


MANIPULAÇÃO DE PASTAS

fs: Modulo FILE SYSTEM. Para manipulação de pastas e arquivos.

	ex.: const fs = require('fs');
	
	Para fazer o requerimento do módulo FileSystem.


	* fs.existsSync() : Para VERIFICAR se uma pasta EXISTE.

	* fs.mkdirSync() : Para CRIAR uma pasta.

	* fs.renameSync() : Para RENOMEAR uma pasta.

	* fs.rm() : Para DELETAR uma pasta.
	
	* fs.rmdir(): Para DELETAR uma pasta VAZIA.


	EXEMPLO de CRIAR pasta:
	 
		- if(!fs.existsSync('./public')) {
    			fs.mkdirSync('./public', (err) =>{
        			if(err) {
            				throw err;
        			}
        			console.log('Pasta criada com 
				sucesso!');
    			})
		  }

		1 - if(!fs.existsSync('./public')):
		SE NÃO(!) EXISTIR A PASTA ./public...

		2 - fs.mkdirSync('./public', (err) =>{} :
		CRIA A PASTA ./public, e a função para determinar
		o que vai acontecer quando criar a pasta. 

		  * 'err': Como parametro, REFERE-SE ao ERRO.

		3- if(err){} :
		SE EXISTIR ERRO(err)...

		4- throw err; :
		Vai MOSTAR o erro no terminal.
		  * throw: Interrupção de Fluxo.(Como o 'return')

		5- console.log('Pasta criada com sucesso!'); :
		SE NÃO TIVER ERRO, vai mostar a mensagem.
		
		
	EXEMPLO de RENOMEAR pasta:

		- if(fs.existsSync('./public')) {
    			fs.renameSync('./public', './bernardo', 
			(err) =>{
        			if(err) {
            				throw err;
        			}
        			console.log('Pasta RENOMEADA com 
				sucesso!');

    			})
		  }

		1- if(fs.existsSync('./public')) {} :
		SE EXISTIR A PASTA ./public...

		2- fs.renameSync('./public', './bernardo', 
		   (err) =>{} :
		RENOMEIA A PASTA ./public, PARA ./bernardo, e a
		função que determina oque vai acontecer quando 
		renomear a pasta.
		  * 'err': Como parametro, REFERE-SE ao ERRO.

		3- if(err) {} :
		SE TIVER ERRO...

		4- throw err; :
		Vai MOSTAR o erro no terminal.
		  * throw: Interrupção de Fluxo.(Como o 'return')

		5- console.log('Pasta RENOMEADA com sucesso!'); :
		SE NÃO TIVER ERRO, vai mostrar a mensagem.

	
	EXEMPLO de DELETAR pasta COM ARQUIVOS:

		- if(fs.existsSync('./bernardo')) {
    			fs.rm('./bernardo', {recursive: true},
			(err) =>{
        			if(err) {
            				throw err;
        			}
        			console.log('Pasta DELETADA com 
				sucesso!');

    			})
		}

		
		1- if(fs.existsSync('./bernardo')) {} :
		SE EXISTIR A PASTA ./bernardo...

		2- fs.rm('./bernardo', {recursive: true}, 
		   (err) =>{} :
		- DELETA A PASTA ./bernardo, 
		- TAMBÉM OS ARQUIVOS RECURSIVOS,
		- E a função que determina oque vai acontecer 
		  quando renomear a pasta.

		  * 'err': Como parametro, REFERE-SE ao ERRO.
		  * Se você não especificar a opção 
		    recursive: true, fs.rm() apenas removerá 
		    arquivos e diretórios vazios.

		3- if(err) {} :
		SE TIVER ERRO...

		4- throw err; :
		Vai MOSTAR o erro no terminal.
		  * throw: Interrupção de Fluxo.(Como o 'return')

		5- console.log('Pasta DELETADA com sucesso!'); :
		SE NÃO TIVER ERRO, vai mostrar a mensagem.


	EXEMPLO DELETAR uma pasta VAZIA:

		- fs.rmdir('./bernardo', (err) =>{} :

		Assim vai apagar a pasta se ela estiver VAZIA.


MANIPULAÇÃO DE ARQUIVOS

    CRIAR/ATUALIZAR:

	* fs.writeFile() : Substitui o ARQUIVO E O CONTEÚDO caso 
			   ele já exista, e se não existir, cria 
			   um novo arquivo com o conteúdo que vc
			   passar.

		ex.: 

		fs.writeFile('teste.txt', 'teste de conteúdo!', 
		(err)=>{
    			if(err){
        			throw err;
   			 }
   		 	console.log('Arquivo criado com sucesso!');
		})


	     EXPLICAÇÃO POR LINHA:

		1- fs.writeFile('teste.txt', 'teste', (err)=>{}) :
		Cria o arquivo, com 3 parametros:
			- 'teste.txt': NOME DO ARQUIVO;
			- 'teste': CONTEÚDO;
			- (err)=>{}: FUNÇÃO PARA DETERMINAR O QUE
				     ACONTECE QUANDO CRIA ARQUIVO.
		
		2- if(err){} : SE TIVER ERRO...

		3- throw err; : MOSTRA O ERRO.

		4- console.log('Arquivo criado com sucesso!');
		SE NÃO TIVER ERRO, mostra a mensagem.

	OBS.: CUIDADO ao usar este método, pois ele pode 
	      SOBRESCREVER o arquivo caso ele já exista. SEMPRE
	      faça uma verificação antes:
		
			ex.: if(!fs.existsSync('teste.txt')){...}
			SE NÃO EXISTIR O ARQUIVO 'teste.txt'...



     * fs.appendFile() : Adiciona conteúdo ao arquivo, se o
			    arquivo não existir ele cria.

		ex.: 
		fs.appendFile('teste.txt', 'Conteúdo ADICIONADO',
		(err)=>{
    			if(err){
        			throw err;
    			}
    			console.log('Arquivo ATUALIZADO!');
		})

	     EXPLICAÇÃO POR LINHA:

		1- fs.appendFile('teste.txt', 'teste', (err)=>{}) :
		ADICIONA CONTEÚDO ao arquivo(OU CRIA) SEM 
		SOBRESCREVER. Com 3 parametros:
			- 'teste.txt': NOME DO ARQUIVO;
			- 'teste': CONTEÚDO;
			- (err)=>{}: FUNÇÃO PARA DETERMINAR O QUE
				     ACONTECE QUANDO CRIA ARQUIVO.
		
		2- if(err){} : SE TIVER ERRO...

		3- throw err; : MOSTRA O ERRO.

		4- console.log('Arquivo ATUALIZADO!');
		SE NÃO TIVER ERRO, mostra a mensagem.
		
	OBS.: MÉTODO MAIS RECOMENDADO, pois não há risco de perca
	      de arquivos, já que este método não SOBRESCREVE nada.



     * fs.open() : Abre um arquivo para leitura, se o arquivo 
		      não existir ele cria um VAZIO. Para criar um 
		      arquivo usar a flag 'w'(writing) para 
		      escrita. 

		ex.: 
		fs.open('arquivo.txt', 'w', (err, file)=>{
    			if(err) {
        			throw err;
    			}
    			console.log('Salvo!')
		})

	     EXPLICAÇÃO POR LINHA:

		1- fs.open('arquivo.txt', 'w', (err, file)=>{} :
		CRIA ARQUIVO VAZIO. Com 3 parametros:
			- 'arquivo.txt': NOME DO ARQUIVO;
			- 'w': FLAG para WRITING(escrever);
			- (err, file)=>{}: FUNÇÃO PARA DETERMINAR
					   O QUE ACONTECE QUANDO 
					   CRIA ARQUIVO.
		
		2- if(err){} : SE TIVER ERRO...

		3- throw err; : MOSTRA O ERRO.

		4- console.log('Salvo!')
		SE NÃO TIVER ERRO, mostra a mensagem.

	OBS.: MÉTODO NÃO RECOMENDADO, pois este método é melhor
	      para ABRIR arquivos, e não para CRIAR arquivos.


    RENOMEAR/DELETAR:

     * fs.rename(): Renomear arquivos.

		ex.: 
		fs.rename('arquivo.txt', 'bernardo.txt', (err)=>{
    			if(err) {
        			throw err;
    			}
    			console.log('Arquivo RENOMEADO!');
		});

	    EXPLICAÇÃO POR LINHA:

		1- fs.rename('arquivo.txt', 'bernardo.txt', 
		   (err)=>{} :
		RENOMEIA o ARQUIVO, com 3 parametros:
			- 'arquivo.txt': NOME DO ARQUIVO;
			- 'bernardo.txt': NOVO nome do arquivo;
			- (err)=>{}: FUNÇÃO CALLBACK.

		2- if(err){} : SE TIVER ERRO...

		3- throw err; : MOSTRA O ERRO.

		4- console.log('Arquivo RENOMEADO!');
		SE NÃO TIVER ERRO, mostra a mensagem.

	OBS.: É INTERESSSANTE verificar se o arquivo que você 
	      deseja renomear EXISTE:

		ex.: if(fs.existsSync('arquivo.txt')){...} :
		SE O ARQUIVO 'arquivo.txt' EXISTE...

	
     * fs.unlink() : EXCLUIR ARQUIVO.

		ex.: 
		fs.unlink('bernardo.txt', (err)=>{
    			if(err) {
       				throw err;
    			}
    			console.log('Arquivo DELETADO!');
		});

	     EXPLICAÇÃO POR LINHA:

		1- fs.unlink('bernardo.txt', (err)=>{} :
		DELETA o ARQUIVO, com 2 parametros:
			- 'bernardo.txt': NOME DO ARQUIVO;
			- (err)=>{}: FUNÇÃO CALLBACK.

		2- if(err){} : SE TIVER ERRO...

		3- throw err; : MOSTRA O ERRO.

		4- console.log('Arquivo DELETADO!');
		SE NÃO TIVER ERRO, mostra a mensagem.

	OBS.: É INTERESSSANTE verificar se o arquivo que você 
	      deseja renomear EXISTE.


    LER ARQUIVOS:

       * fs.readFile() : Ler arquivo.

		ex.: 
		fs.readFile('projeto-node/public/index.html', 
		(err, content)=> {
                	if(err) {
                    		throw err;
               		}
                	res.setHeader('Content-type', 'text/html');
                	res.end(content);
           	});

	     EXPLICAÇÃO POR LINHA:
		
		1- fs.readFile('projeto-node/public/index.html', 
		   (err, content)=> {} :
		LER ARQUIVO, com 2 parametros:
			- LOCAL DO ARQUIVO;
			- FUNÇÃO CALLBACK com 2 parametros:
				- err: ERRO;
				- content: CONTEÚDO.
			
		2- if(err){} : SE TIVER ERRO...

		3- throw err; : MOSTRA O ERRO.

		4-  res.setHeader('Content-type', 'text/html'); :
		ADICIONA um cabeçalho ao SERVIDOR, com 2 param.:
			- TIPO DO CONTEÚDO;
			- FORMATO DO CONTEÚDO;
		
		5- res.end(content); :
		FINALIZA A REQUISIÇÃO e mostra o CONTEÚDO do 
		arquivo LIDO (index.html).
		




EXPRESS

SCRIPT DOS EXEMPLOS: /projeto-node/express.js

Express é um Framework para nodeJS minimalista que diminui linhas
de código por já ter vários modulos dentro dele.

EXEMPLO DE CRIAÇÃO DE SERVIDOR:

	- const express = require('express');

	  const app = express();

	  const PORT = process.env.PORT || 3000;

	  app.get('/', (req, res) => {
    		res.send('<h1>Hello World!</h1>');
	  });

	  app.listen(PORT, ()=> {
    		console.log(`Servidor rodando em http://localhost:
		${PORT}`);
	  });


* const express = require('express'); : Para fazer a REQUISIÇÃO
					do EXPRESS.


* const app = express(); : Constante PADRÃO para pegar todos o
			   conteúdo de dentro do Express. Esta
			   constante é por onde faremos o uso de
			   todas as funções do Express.


* const PORT = process.env.PORT || 3000; : Da mesma forma que o 
					   método 'http', é 
				  	   necessário criar uma
					   PORTA para o servidor.


* app.get('/', (req, res) => {} : Para definir ROTAS. Neste caso
				  PEGAR(get), a pagina 
				  principal('/') e mostrar algo.
				  Por padrão a função de tem 2 
				  parametros 'req' e 'res' onde 
				  a RESposta será mostrada pelo
				  parametro 'res'.

			Parametros:
				1- Pagina;
				2- Função;


*  res.send('<h1> ... </h1>'); : O metodo .send serve para ENVIAR
				  algo como resposta('res'), neste
				  caso, para a página PRINCIPAL. 
				  Que no caso foi um <h1>.


* app.listen(PORT, ()=> {} : Para dar START ao servidor. Basta 
			     apenas indicar a PORTA nos parametros
			     mas se for necessário podemos 
			     utilizar uma função de CALLBACK.



PARA ENVIAR UM ARQUIVO COMO RESPOSTA:


* res.sendFile(__dirname + '/public/index.html'); :


	- .sendFile() : Para ENVIAR um ARQUIVO.

	- __dirname : Para dar o local ABSOLUTO do ARQUIVO.
		      É necessário SEMPRE dar o local absoluto.

	- + '/LocalDoArquivo.html' : É necessário CONCATENAR(+),
	  			     pois antes veio o modulo 
				     '__dirname' e dar o local do
	  			     arquivo.


PARA CRIAR ROTAS COM PAGINAS DIFERENTES NO SERVIDOR:

- A ROTA de exemplo: carros/fiat/uno

	1- Crie um novo arquivo .js(javascript) para criar as 
	   rotas.

	2- Faça a requisição do EXPRESS:
		
		- const express = require('express');

	3- Crie uma constante/variavel para pegar o MÉTODO 
	   expecifico para ROTAS.

		- const router = express.Router();
		
		.Router : É o MÉTODO do express próprio para rotas.

	4- Crie as rotas:
	
		- router.get('/', (req, res)=> {...}

		ROTA PARA '/'(PAGINA PRINCIPAL)...

		- router.get('/fiat', (req, res)=> {...}

		ROTA PARA '/fiat'...

		- router.get('/fiat/uno', (req, res)=> {...} 
		
		ROTA PARA '/fiat/uno'

	5- EXPORTE AS ROTAS COMO MODULO PARA O SEU SERVIDOR:

		- module.exports = router;

		LEMBRANDO 'router' é a constante das rotas...


    NO SCRIPT DO SERVIDOR...

	6- FAÇA A REQUISIÇÃO DO MODULO DAS ROTAS CRIADAS.

		- const rotas = require('./routes/carros.js');
		
		obs.: SEMPRE dê o local do arquivo onde se 
		      encontra o SEU modulo de rotas.

	7- CHAME AS ROTAS DO SEU MODULO:

		- app.use('/carros', rotas);

		   * .use : serve para usar uma rota de um módulo 
			 externo.

		   * '/carros' : É a rota onde você quer que a 
				 pagina principal('/') do seu 
				 módulo comece.

		   * rotas : é a constante onde foi feita a 
		 	     requisição do módulo das rotas.

	8- Agora a página principal das suas rotas é '/carros'.
	   Para acessar as outras páginas basta digitar na barra:

		- carros/fiat : Para a página fiat.

		- carros/fiat/uno : Para a página Uno.

	SCRIPT DO EXEMPLO:
	
		- curso-nodejs/projeto-node/routes/carros.js

	SCRIPT DO SERVIDOR EXPRESS: 
	
		- curso-nodejs/projeto-node/express.js



MIDDLEWERES
		
Middlewares = INTERMEDIÁRIO = INTERCEPTADOR = MEIO.

É a FUNÇÃO que executa uma ação entre o INICIO de uma requisição e
o FIM de uma requisição.
TODA VEZ em que aplicamos o método LISTEN(app.listen), estamos 
INICIANDO uma requisição, e TODA VEZ que exibimos algo para o
usuário(res.send), estamos FINALIZANDO uma requisição.

Um MIDDLEWARE tem um diferencial, que é um parametro a mais na 
função: o NEXT.

	ex.: 

	app.get('/', (req, res, next)=> {
    	    	console.log('Eu sou um MIDDLEWARE!')
    		next();
	});

	EXPLICAÇÃO POR LINHA:
	
		1- app.get('/', (req, res, next)=> {}
		Uma requisição é inicializada como qualquer outra
		definição de rota, porem na função MIDDLEWARE tem
		outro parametro:
			* req : requisição;
			* res: resposta;
			* next: OQUE TORNA UM MIDDLEWARE.

		2- console.log('Eu sou um MIDDLEWARE!') :
		O que vai acontecer antes da resposta da 
		requisição.

		3- next() :
		Chama a próxima função de middleware na sequência.
	
	
MIDDLEWARES são utilizados para executar uma ação, seja uma 
Autenticação, Validação de Dados, Logging. ANTES que a resposta
seja mostrada ao usuário.

	EXEMPLO DE MIDDLEWARES DE AUTENTICAÇÃO:

	const usuarioLogado = false;

	app.use('/restrita', (req, res, next)=> {
    		if(!usuarioLogado){
        		res.redirect('/');
    		}
    		next();
	})

	EXPLICAÇÃO POR LINHA:

		1- const usuarioLogado = false;
		Constante que indica que o usuario não esta logado.

		2- app.use('/restrita', (req, res, next)=> {};
		Criação da middleware, para a pagina '/restrita'.

		3- if(!usuarioLogado){} :
		SE o usuario NÃO(!) estiver logado...

		4- res.redirect('/'); :
		REDIRECIONA a pagina inicial.

		5- next() :
		SE o usuário estiver logado, vai liberar o acesso.
		as PROXIMAS(next) páginas.
	



HANDLEBARS

é uma ferramenta que facilita a criação de HTML dinâmico em 
aplicações Node.js. Ele é um motor de templates que permite 
separar a lógica de apresentação do código, tornando a construção
de interfaces de usuário mais simples e eficiente.

PARA INSTALAR HANDLEBARS NO SEU PROJETO:

- npm install express-handlebars --save


CONFIGURAÇÃO PADRÃO PARA HANDLEBARS
   
	* app.engine('hbs', hbs.engine({
    	  	extname: 'hbs',
    	  	defaltLayout: 'main',

	  }));
	  app.set('view engine', 'hbs');

	EXPLICAÇÃO POR LINHA:

	1- app.engine('hbs', hbs.engine({}) :
		- app.engine: Para definir o MOTOR de renderização 
			    para o FRONTEND do nosso projeto;

		- 'hbs' : Sigla para HANDLEBARS;

		- hbs.engine : Para configurar o HANDLEBARS. Onde
			       o 'hbs' é a constante que contem o
			       handlebars e '.engine' para 
			       configurar o motor.

	2- extname: 'hbs', : Para definir que os arquivos 
	   		     '.handlebars' possam ser nomeados 
			     usando apenas a sigla '.hbs'. 

	3- defaltLayout: 'main', : Para definir que a pagina 
				   'main' será o layout padrão.

	4- app.set('view engine', 'hbs') : Para indicar ao express
					   que queremos usar a 
					   engine handlebars.

PASSOS IMPORTANTES:

	* É OBRIGATÓRIO que criemos uma pasta chamada 'views' na
	  pasta raiz do projeto.
	
	* É OBRIGATÓRIO que criemos dentro da pasta 'views' outra
	  pasta chamada 'layouts'.

	* É OBRIGATÓRIO que criemos dentro da pasta 'layouts' um
	  arquivo chamado 'main.hbs'.(Que é o arquivo ao que se 
	  refere a configuração 'defaltLayout: 'main'').

	* Dentro do arquivo 'main.hbs' iremos criar uma variavel
	  dentro da tag <body> assim: {{{body}}}. Esta váriavel
	  '{{{body}}}' é onde todas as páginas que criaremos vão
	  aparecer.

	* Dentro da pasta 'views'(e fora da pasta 'layouts') é
	  onde criaremos todas as nossas páginas.


PARA MOSTRAR COMO RESPOSTA(res) AS PÁGINAS CRIADAS .hbs

	* app.get('/', (req, res)=> {
    	  	res.render('index');
	  });

	EXPLICAÇÃO:

	- res.render('nomeDaPagina') :

	O método '.render()' é para RENDERIZAR(com o motor hbs) a
	página que criamos dentro da pasta 'views'.
	OBS.: Não precisa colocar o .hbs . E a pasta NÃO pode 
	estar dentro de outras pastas, TEM QUE ESTAR dentro da
	pasta RAIZ.


PARA MOSTRAR INFORMAÇÕES DO BACKEND NO FRONTEND

   Dentro da nossa difinição de ROTA(.get) na RESPOSTA(res) 
   podemos criar OBJETOS{} para capturar informações e mostrar no 
   FRONTEND.

	ex.: app.get('/', (req, res)=> {
    		res.render('index', {nome: 'Bernardo'});
	     });

	Dentro da RESPOSTA(res.render) criamos o OBJETO 'nome'.

   Para mostrar este objeto no FRONTEND basta utilizar 
   chaves duplas = {{objeto}} dentro de uma tag.

	ex.: <h1>{{nome}}</h1>

	Com a utilização das chaves duplas e o nome do objeto 
	dentro podemos mostrar a informação contida dentro do
	objeto no frontend.


PARA UTILIZAR ARQUIVOS ESTATICOS (.js / .css)

   Para utilizar arquivos estaticos como o nosso proprio SCRIPT e
   o CSS, temos que criar uma MIDDLEWARE que indique que queremos
   utilizar arquivos estaticos.

	ex.: app.use(express.static('public'));

	O método 'express.static' indica que queremos utilizar 
	arquivos estaticos. E dentro dos paranteses damos a pasta
	PUBLIC que é onde os nossos arquivos devem estar.

	OBS.: Quando formos referenciar os links na nossa pagina
	      'main', o 'href' já estará como se estivesse dentro
	      da pasta PUBLIC, portanto basta colocar apenas a '/'
	      e o nome do arquivo.

		ex.: <link rel="stylesheet" href="/css/style.css">


PARA ADICIONAR UM HEADER NA PAGINA PRINCIPAL(main.hbs)

1- É necessário criar uma pasta chamada 'partials' dentro da pasta
   'views'. PARTIAL é para arquivos parciais que vão aparacer 
   sobre a página.

2- Dentro da pasta 'partials' criamos um arquivo .hbs que será
   onde iremos colocar nossos HEADERS.

3- Na pagina 'main.hbs' é necessário colocar na posição onde
ficaria o HEADER(semântico), este codigo: {{>NomeDoArquivo}}

	ex.: {{>nav}}

	* >nav : Siginifica que vamos utilizar um arquivo chamado
		'nav.hbs' da pasta 'partials'.


PARA ADICIONAR CONDIÇÕES AO HANDDLEBARS(if)

Dentro da classes(class) dos itens HTML dos arquivos .hbs é onde 
podemos fazer alterações, e também podemos fazer condições para
itens coma ajuda dos objetos que podemos criar na RESPOSTA(res)
das ROTAS(res.render).

	ex.: app.get('/users', (req, res)=> {
    		res.render('users', {users: true});
	     });

	- Como podemos ver, na resposta(res.render), criamos um 
	  objeto chamado 'users' com um valor booleano 'true'. 
	  Que será valido toda vez que acessar a pagina '/users'.

Agora, dentro de uma tag de um arquivo .hbs podemos adicionar uma
condição(if), para toda vez que o objeto 'users' existir acontecer 
alguma mudança.

Para criar um IF em uma class de uma tag HTML utilizamos:
	- {{#if condição}}

Para fechar a tag IF utilizamos:
	- {{/if}}

E ENTRE estes sinais vai oque acontece se a condição for aceita.

	ex.: <a class="{{#if users}} active {{/if}}">

	- DENTRO DA CLASSE da tag <a>, SE 'users' existir, a tag
	  <a> recebe o atributo 'acitive'.



PARA LER OS VALORES DE UM FORMULÁRIO

- BODYPARSER
O body-parser permite que o seu servidor Node.js com Express possa
ler e interpretar os dados enviados no corpo de uma requisição 
HTTP.

1- É necessário fazer a requisição(require) para ler e interpretar 
   valores do formulário do FRONTEND para o BACKEND.

	* const bodyParser = require('body-parser');

2- CONFIGURAR o leitor de valores por meio de uma middleware.

	* app.use(bodyParser.urlencoded({extended:false}));

		- .urlencoded() : Para lidar com dados CODIFICADOS
				  da URL.
		- { extended: false } :  significa que ele só pode
					 analisar dados simples.
					 e não suporta objetos 
					 aninhados ou matrizes.

3- NO FORMULÁRIO com metodo POST colocamos o atributo 'action'.¨

	* <form action="/cadastro" method="post">

		- action='/cadastro': DEFINE para ONDE queremos 
				      enviar os valores dos inputs
				      do formulário. DEFINIR A 
				      ROTA.

4- Criamos a ROTA para RECEBER os valores do formulário.

	* app.post('/cadastro', (req, res)=> {
    		res.send(req.body.email);
	  });
		- app.post(): um método que define uma rota 
			      para lidar com REQUISIÇÕES(req).
				
			      .post = req  // .get = res

		- req.body.email : 
			* req.body : É onde os valores do 
				     formulario são guardados.

			* .email : É o atributo 'name' do input.
				   Neste caso queremos pegar 
				   apenas o valor no input de
				   NOME 'email'.

		OBS.: É MUITO IMPORTANTE o atributo NAME do input,
		      pois são apartir deles que conseguimos pagar
		      os valores de um input especifico.

	É nesta ROTA de REQUISIÇÃO em que podemos fazer várias 
	coisas, como: 
		- VALIDAÇÃO DOS VALORES que vieram do form;
		- TRATAMENTO DESTES VALORES;
		- ENVIAR ESTES VALORES para um banco de dados... 



VALIDAÇÃO DE VALORES DE UM FORMULÁRIO  
					 
Dentro da ROTA '.post' de REQUISIÇÃO, vamos fazer a validação dos
valores vindos do formulário.

1- Criar variáveis que vão receber os valores dos inputs do form.

	- var nome = req.body.nome;
    	  var email = req.body.email;
	
		* var nome = req.body.nome; : 
			Vai receber o valor (req.body) do input de
			atributo 'name:' igual a 'nome'.
		 
		* var email = req.body.email; : 
			Vai receber o valor (req.body) do input de
			atributo 'name:' igual a 'email'.


2- Método para REMOVER ESPAÇOS EM BRANCO: .trim()

	- nome = nome.trim();
    	  email = email.trim();

	O método '.trin()' remove todos os espaços em branco de
	dentro dos valores das variaveis.


3- RegEx para REMOVER CARACTERES ESPECIAIS.

	- nome = nome.replace(/[^A-zÀ-ú/s]/gi,'')

		* .replace() : Para SUBSTITUIR caracteres. Este 
			     método tem 2 parametros:
				1- Caractere que você quer que 
				   seja	SUBSTITUIDO.
				2- Caractere que você quer que 
				   SUBSTITUA.

		* /[^A-zÀ-ú/s]/gi : RegEx(Expressões Regulares),
				    com algumas cofigurações:
				
			- /[ ]/ : Abre e fecha uma RegEx.
			- ^ : Ancora que corresponde ao inicio da
			      RegEx.
			- A-z : De A(maiusculo) a z(minusculo),
				significa que será ACEITO
				caracteres de A a Z maiusculo ou 
				minusculos.
			- À-ú : De À(maiusculo crazeado) a 
				ú(minusculo acentuado),
				significa que a sequencia de
				vogais de A a U maiuscula ou 
				minuscula / acentuada ou crazeada
				também serão ACEITOS.
			- /s : Significa espaços em branco, que
			       também serão ACEITOS.

			- gi : Significa que a expressão regular 
			       deve encontrar TODAS as OCORRENCIAS
			       do padrão, independentemente se 
			       estão escritas em maiúsculas ou 
			       minúsculas.

4- Se o valor da variável está VAZIO, INDEFINIDO ou NULO

	-  const erros = [];

	   if(nome == '' || typeof nome == undefined || 
	   nome == null) {
        	erros.push({mensagem: 'Campo nome não pode ser 
		vazio!'})
    	   };

		* const erros = []: Array para guardar os erros.

		* nome == '': Se 'nome' for igual a VAZIO.

		* typeof nome == undefined: Se TIPO DE(typeof)
					    'nome' for igual a
					    INDEFINIDO.

		* nome == null: Se 'nome' for igual a NULO.

		* erros.push({mensagem: '...'}): 
			Para ADICIONAR ao array 'erros' um OBJETO
			com o parametro 'mensagem'.

5- Verificar se o valor da variável é VALIDO.
	
	- if(!/^[A-Za-záàâãéèêíïóôõöúçñÁÀÂÃÉÈÍÏÓÔÕÖÚÇÑ ]+$/.test
	  (nome)) {
        	erros.push({mensagem: 'Nome inválido!'});
    	  } 

		* if(!): Se NÃO.

		* /^[A-Za-záàâãéèêíïóôõöúçñÁÀÂÃÉÈÊÍÏÓÔÕÖÚÇÑ ]+$/ :
			- A-Z: Letras de A-Z(maiusculas);
			- a-z: Letras de a-z(minusculas);
			- áàâãéèêíïóôõöúçñ: Letras acentuadas,
					    ç e ñ (minusculas).
			- ÁÀÂÃÉÈÊÍÏÓÔÕÖÚÇÑ: Letras acentuadas,
					    ç e ñ (maiusculas).

		* .test(nome): Para verificar se a RegEx 
			       corresponde a variável 'nome'.
			       Neste caso SE NÃO corresponde.

		* erros.push({mensagem: '...'}): 
			Para ADICIONAR ao array 'erros' um OBJETO
			com o parametro 'mensagem'.


6- Para verificar se um EMAIL é INVALIDO:

	- if(!/^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/
	  .test(email)) {
        	erros.push({mensagem: 'Email inválido!'});
    	  }

		* if(!): Se NÃO. 

		* /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/

			- ^: Início da string (e-mail);

			- [a-zA-Z0-9._-]+: Permite letras 
				(maiúsculas e minúsculas), números
				, ponto, sublinhado e hífen, um 
				ou mais vezes.
		
			- @: Caractere "@" obrigatório.

			- [a-zA-Z0-9.-]+: Permite letras, números,
				 ponto e hífen, um ou mais vezes.

			- \.: Ponto literal.

			- [a-zA-Z]{2,}: Permite duas ou mais 
					letras (domínio).

			- $: Fim da string. 

		* .test(email): Para verificar se a RegEx 
			        corresponde a variável 'email'.
			        Neste caso SE NÃO corresponde.

		* erros.push({mensagem: '...'}): 
			Para ADICIONAR ao array 'erros' um OBJETO
			com o parametro 'mensagem'.



PARA GUARDAR ERROS DE UMA VALIDAÇÃO EM UMA SESSÃO(express.session):

Para armazenar os erros de uma validação é necessário criar uma 
SESSÃO. 

SESSÃO, armazena dados da sessão no servidor, permitindo que o 
estado de um usuário seja mantido entre solicitações. A sessão é 
identificada por um ID, que é armazenado num cookie no cliente. 

Basicamente, guardar dados em uma requisição(ROTA) e conseguir 
usar-las em escopo GLOBAL.

1- PARA INSTALAR EXPRESS.SESSION NO PROJETO:

	- npm install express-session --save

2- Fazer a requisição do modulo.

	- const session = require('express-session');

3- CONFIGURAR a sessão:

	- app.use(session({
    		secret: 'CriaUmaChaveQualquer',
    		resave: false,
    		saveUninitialized: true
	  }));	

	EXPLICAÇÃO POR LINHA:

		1- app.use(session({})) :
		Middleware para configurar a seção. As 
		configurações ficam em um objeto{}.

		2- secret: 'CriaUmaChaveQualquer':
		Chave secreta para criptografar o cookie da sessão

		3- resave: false : 
		Não forçar salvar a sessão se não foi alterada.

		4- saveUninitialized: true :
		Não salvar sessões não iniciadas.

4- Acessar a SESSÃO em uma requisição e guardar valores.
	
     Para acessar a sessão basta usar 'req.session', e para 
     armazenar algum dado é necessário que coloque o nome da propriedade
     depois:
         ex.: req.session.errors. 
     Neste caso para armazenar os erros. Daí é só dar o valor que
     a sessão irá guardar.

	- app.post('/cadastro', (req, res)=> {
		const erros = [...];
		if(erros.length > 0) {
	  		req.session.errors = erros;
          		req.session.sucess = false;
          		return res.redirect('/');
		};
		req.session.sucess = true;
		return res.redirect('/');
	  });

	EXPLICAÇÃO POR LINHA:

		1- app.post('/cadastro', (req, res)=> {}):
		Requisição para a rota '/cadastro'

		2- const erros = [...]: 
		Constante onde foram armazenados os ERROS.

		3- if(erros.length > 0) {}:
		Se o COMPRIMENTO do array 'erros' for maior que 0...

		4- req.session.errors = erros:
		Manda a sessão armazenar o array 'erros' na 
		propriedade '.errors'.

		5- req.session.sucess= false:
		Manda a sessão armazenar o valor FALSE na 
		propriedade '.sucess'.
		VALIDAÇÃO NÃO TEVE SUCESSO.

		6- return res.redirect('/'):
		Manda RETORNAR a RESPOSTA(res) redirecionando para
		a pagina principal('/').

		7- req.session.sucess = true:
		Caso NÃO tenha ERROS, manda a sessão armazenar
		o valor TRUE na propriedade '.sucess'.
		VALIDAÇÃO TEVE SUCESSO.

		8- return res.redirect('/'):
		Manda RETORNAR a RESPOSTA(res) redirecionando para
		a pagina principal('/').
	
			

MOSTRAR MENSAGENS DE SUCESSO/ERRO.

1- Na pasta PARTIALS vamos criar um arquivo chamado 'msg.hbs', que
   será onde ficarão os ALERTS de sucesso e erro.

2- Como EXISTINDO ou NÃO EXISTINDO erros redirecionamos para a 
   página principal('/')...
   NA ROTA DA PÀGINA PRINCIPAL VAMOS VERIFICAR SE HOUVERAM ERROS 
   OU NÃO:

	- app.get('/', (req, res)=> {
    		if(req.session.errors){
        	     let arrayErros = req.session.errors;
        	     req.session.errors = '';
       		     res.render('index', {msgError: arrayErros});
    		};
   		if(req.session.sucess){
		     req.session.sucess = false;
        	     res.render('index', {msgSucess: true});
    		}
	  });

	EXPLICAÇÃO POR LINHA:

	1- app.get('/', (req, res)=> {}):
	Rota para pagina principal '/'.

	2- if(req.session.errors){}:
	SE EXISTIR a propriedade '.errors' na SESSÃO...

	3- let arrayErros = req.session.errors;
	Cria uma variavel que recebe os ERROS da SESSÃO.

	4- req.session.errors = '':
	A propriedade '.errors' da SESSÃO recebe VAZIO. Para que
	toda vez que haja a VALIDAÇÃO a propriedade '.errors' da 
	SESSÃO esteja vazia para receber os valores da nova
	requisição.

	5- res.render('index', {msgError: arrayErros}):
	Vai RESPONDER(res.render):
		- 'index': A página 'index.hbs'.
		- {msgError: arrayErros}: Cria o objeto 'msgError'
					  que recebe a variavel
				   	  'arrayErros', que tem
					  os erros da SESSÃO.

	6- if(req.session.secess){}:
	SE a propriedade da SESSÃO '.sucess' existir(true)...

	7- req.session.sucess = false:
	Para que a propriedade da SESSÃO '.sucess' volte ao seu
	estado original. E quando atualizarmos a página a mensagem
	suma da tela e aguarde a nova interação do usuário.

	8- res.render('index', {msgSucess: true}):
	Vai RESPONDER(res.render):
		- 'index': A página 'index.hbs'.
		- {msgSucess: true}: Cria o objeto 'msgSucess'
				     que recebe TRUE.

3- CONDIÇÕES para as mensagens na APARECEREM tela.

    No arquivo 'msg.hbs' da pasta PARTIAL...
    Vamos fazer condições para a mensagem de SUCESSO e de ERRO:

	* {{#if msgSucess}}
	  <div class="alert alert-success" role="alert">
  		Cadastrado com SUCESSO!
	  </div>
	  {{/if}}

	- SE o objeto 'msgSucess' EXISTIR, vai mostrar a mensagem 
	de SUCESSO.


	* {{#each msgError}}
	  <div class="alert alert-danger" role="alert">
  		{{mensagem}}
	  </div>
	  {{/each}}

	- SE o objeto 'msgError' EXISTIR, vai PERCORRER-lo(each).
	OBS.: Porque 'msgError' é um array.
	- Vai mostrar o objeto 'mensagem' de cada indice do array
	  'msgError'.	

4- MOSTRAR as mensagens na tela:

     Para mostrar a mensagem basta, no arquivo raiz 'main.hbs' ou
     no arquivo do FORMULÁRIO(index.hbs) e 
     indicar que quer mostrar a mensagem, desta forma:

	- {{>msg}}

	* Isto indica que queremos mostrar o arquivo 'msg.hbs' da
	  pasta PARTIALS('>').

    Pronto, sempre que uma das condições do arquivo 'msg.hbs' ou
    'index.hbs'(Dependendo da sua escolha) for verdadeira, 
    vai mostrar a mensagem correspondente.




ARMAZENANDO DADOS EM UM BANCO DE DADOS(MySQL)

	ARQUIVO USADO PARA EXEMPLOS: crud-node/models/db.js

   ORM(Object-Relational Mapping)
	
   É uma técnica que simplifica a interação entre código de 
   aplicação e bancos de dados relacionais. Em vez de escrever 
   consultas SQL diretamente, os desenvolvedores podem trabalhar 
   com objetos que são automaticamente mapeados para tabelas no 
   banco de dados.
   EM OUTRAS PALAVRAS... 
   É o responsável por fazer o meio de campo, entre o nosso App e
   o BANCO DE DADOS. E neste caso vamos usar o SEQUELIZE.


   SEQUELIZE

   É um ORM para Node.js, permitindo trabalhar com objetos 
   JavaScript em vez de escrever SQL diretamente.


   XAMPP

   É um pacote que contém os principais componentes necessários 
   para criar um servidor web, como o servidor web Apache, um 
   sistema de gerenciamento de banco de dados (MySQL ou MariaDB),
   e interpretadores para as linguagens de programação PHP e Perl.

   Neste caso iremos Utiliza-lo para gerencimaento do banco de 
   dados MySQL. 


   INSTALAR NO PEOJETO:
	- npm install --no-proxy sequelize mysql2 --save


CONFIGURANDO O SEQUELIZE PARA CONECTAR-SE COM O BANCO DE DADOS 


1- Crie uma pasta chamada MODELS. Que por padrão, é onde ficam os
   arquivos relacionados ao BANCO DE DADOS.


2- Crie um arquivo chamado 'db.js'. Para configurar a
   conecção entre a nossa aplicação e o banco de dados.


3- Faça o requerimento dos modulo SEQUELIZE:

	- const Sequelize = require('sequelize');

	OBS.: IMPORTANTE que a constante comece com a letra 
	      MAIUSCULA, Pois o modulo do Sequelize começa com
	      maiuscula.


4- Crie a INSTANCIA para o módulo Sequelize:

	- const sequelize = new Sequelize('banco','usuario', 
	  'senha', {...});


		* const sequelize: Representa a instancia do 
				   modulo Sequelize.

		* new Sequelize(): Cria uma NOVA(new) instancia
				   para o método Sequelize. E nele
				   temos 4 parametros:

			1- 'banco': Nome do Banco de dados;
			2- 'usuario': Usuario;
			3- 'senha': Senha;
			4- {}: Objeto onde vão as configurações
			       de conexão. 


5- Configure a conexão do banco de dados:

	- const sequelize = new Sequelize('banco','usuario',
	  'senha', {
    
    		host: '127.0.0.1',
    		dialect: 'mysql',
    		define: {
        		charset: 'utf8',
       		 	collate: 'utf8_general_ci',
        		timestamps: true
    		},
    		logging: false
	  });


		* host: '127.0.0.1': Numero de IP do 
				     Servidor(host), que no caso é
				     o XAMPP.

		* dialect: 'mysql': Tipo de Banco de dandos, no
				    Dialeto(dialect), que no caso 
				    é MySQL.

		* Logging: false : Para não conjestionar o 
				   terminal com LOGS toda vez que
				   rodar o banco de dados.

		(OPCIONAL) 
		* define: {...} : Para configurações adicionais...

			- charset: 'utf8': Para aceitar todos os
					   caracteres da lingua
					   portuguesa.

			- collate: 'utf8_general_ci': 
				Para a TABELA também aceitar todos
				os caracteres.

			- timestamps: true : Para salvar as 
					     alterações as 
					     informações sobre as
					     alterações, como 
					     data...etc.




CRIANDO O BANCO DE DADOS NO XAMPP

1- Clique START em: Apache(servidor), Mysql(banco).

2- No MySQL Clique em ADMIN para abrir o 'phpMyAdmin'.

3- Clique em 'Novo', Dê um nome ao banco de dados e clique em
   CRIAR.

4- Na INSTANCIA do SEQUELIZE, no PRIMEIRO parametro digite o nome
   do seu Banco de dados. No caso é 'node_exemplo'.
 
   ex.: const sequelize = new Sequelize('node_exemplo','usuario',
       'senha', {...})

5- No usuário por padrão do XAMPP é 'root' e a senha é vazio ('').

   ex.: const sequelize = new Sequelize('node_exemplo', 'root',
        ' ', {...})

6- Teste a conexão do Banco de dados:

	- sequelize.authenticate().then(()=> {
    		console.log('Conexão no banco com Sucesso!');
	  }).catch((err)=> {
   		 console.log('Falha ao se conectar' +err);
	  });

	EXPLICAÇÃO:

		1- sequelize.authenticate(): Para fazer a 
					     autenticação do banco
					     CONECTAR COM O BANCO.

		   * .then(()=>{}): SE DER CERTO(then), e uma 
				    função CALLBACK com uma 
				    mensagem.

		   * .catch((err)=>{}): SE DER ERRADO(catch), com
					uma função CALLBACK com
					um parametro 'err' para 
					capturar o erro e mostrar
					na mensagem da função.

7- Apague o TESTE, para não ficar conectando sempre que rodar o 
   servidor.

8- EXPORTE o MODULO e a INSTANCIA do SEQUELIZE:

	- module.exports = {Sequelize, sequelize};

		* module.exports: Para exportar como objeto{}.

		* Sequelize('S' maiusculo): Modulo do Sequelize.

		* sequelize('s' minusculo): Instancia do Sequelize.




CRIANDO OS MODELOS PARA A CRIAÇÃO DA TABELA NO BANCO DE DADOS

	ARQUIVO PARA OS EXEMPLOS: crud-node/models/Usuario.js

Os MODELS(modelos) representam as tabelas do banco de dados e 
fornecem métodos para realizar operações CRUD (Create, Read, 
Update, Delete) de forma mais organizada e segura.


1- Crie um arquivo(.js) na pasta MODELS para ser o modelo da sua
   tabela. No caso: Usuario.js.

2- No arquivo 'Usuario.js' faça a REQUISIÇÃO do MODULO e da 
   INSTANCIA do Sequelize:

	- const dataBase = require('./db');


3- Crie a constante que vai DEFINIR a tabela:

	- const Usuario = dataBase.sequelize.define('usuario', 
	  {...});

		* dataBase.sequelize: É a constante da requisição
				      chamando a INSTANCIA do 
				      Sequelize.

		* .define(): É o método que vai DEFINIR a tabela.
			     Que recebe 2 parametros:

				- 'usuario': É o NOME da tabela
					     que será criada.

				- {...}: É o objeto que contém os
					 parametros que vão 
					 DEFINIR as colunas da
					 tabela.


4- Determine os PARAMETROS que irão DEFINIR as COLUNAS da tabela:

	- const Usuario = dataBase.sequelize.define('usuario', {
    		id: {
        		type: dataBase.Sequelize.INTEGER,
        		autoIncrement: true,
        		allowNull: false,
        		primaryKey: true
    		},
    		nome: {
        		type: dataBase.Sequelize.STRING,
        		allowNull: false
    		}
	   });

	EXPLICAÇÃO POR LINHA:

		1- id: {} : A COLUNA 'id', que POR PADRÃO sempre
			    será a primeira coluna. E dentro do 
			    objeto{} estão as propriedades da
			    coluna.

		2- type: dataBase.Sequelize.INTEGER:
			É a propriedade que vai definir o TIPO que
			a coluna vai ser.

			- database.Sequelize: É a constante da 
					      requisição chamando
					      o MODULO Sequelize.

			- .INTEGER: É um método do MODULO 
				    Sequelize que define que o
				    valor da coluna será de 
				    NUMEROS INTEIROS(INTEGER).

		3- autoIncrement: true: É a propriedade que 
				  	determina que o valor
					da coluna vai 
					incrementar +1, toda vez
					que uma nova tabela 
					'usuario' for adicionada 
					ao banco de dados.

		4- allowNull: false: Não aceita valores NULOS.

		5- primaryKey: true: Será a COLUNA PRIMARIA da 
				     tabela.

		6- nome: {} : A COLUNA 'nome', E dentro do 
			      objeto{} estão as propriedades da
			      coluna.

		7- type: dataBase.Sequelize.STRING:
			É a propriedade que vai definir o TIPO que
			a coluna vai ser.

			- database.Sequelize: É a constante da 
					      requisição chamando
					      o MODULO Sequelize.

			- .STRING: É um método do MODULO 
				   Sequelize que define que o
				   valor da coluna será de 
				   LETRAS(STRING).

		8-  allowNull: false: Não aceita valores NULOS.


5- SINCRONIZE o MODELO da tabela:

	- Usuario.sync();

		* .sync(): Método do Sequelize para sincronizar o
			   modelo da tabela, e caso a tabela não 
			   exista irá criar uma nova tabela.


6- EXPORTE o MODELO da tabela: 

	- module.exports = Usuario;




INTEGRAR O MODELO DA TABELA AO CÓDIGO PRINCIPAL DO PROJETO

1- Fazer a REQUISIÇÃO do MODELO da tabela no seu 'index.js':

	- const Usuario = require('./models/Usuario');

OBS.: TODA VEZ que RODAR o servidor vai ser CRIADA A TABELA com
      o MODELO dentro do BANCO DE DADOS caso ela não exista.

      Portanto, SEMPRE que rodar o servidor, é OBRIGATÓRIO que o
      servidor APACHE e o MySQL estejam ATIVADOS no XAMPP.
		
		       


SALVAR OS DADOS DO FORMULARIO NO BANCO DE DADOS

Com o MODELO da tabela já integrado ao código principal...
Após todo o processo de VALIDAÇÃO dos dados, e estando tudo certo
vamos salvar os dados no banco de dados.

1- CRIE e ADICONE um novo objeto{} a tabela do banco de dados:

	- Usuario.create({
        	nome: Nome,
        	email: Email.toLowerCase()
    	  })


		* Usuario.create({...}): Cria um novo objeto 
					 usando o MODELO como base
					 E adiciona o objeto a 
					 tabela no banco de dados.

		* nome: Nome : A COLUNA 'nome' recebe a 
			       variavel 'Nome'(o valor dela).

		* email: Email.toLowerCase(): A COLUNA 
				'email' recebe a variavel 'Email',
				em letras minusculas(toLowerCase).

2- VERIFIQUE se deu CERTO(.then) ou ERRADO(.catch):

	- Usuario.create({
        	nome: nome,
        	email: email.toLowerCase()
    	  }).then(()=> {
        	console.log('Cadastrado com sucesso!');
        	req.session.sucess = true;
        	return res.redirect('/');
    	  }).catch((err)=> {
        	console.log('Ops...Houve algum erro: '+ err);
    	  });

	EXPLICAÇÃO POR LINHA:

		1- Usuario.create({...}): Cria e adiciona o objeto
					  ao banco de dados.

		2- .then(()=>{...}) : SE DER CERTO(then), e uma 
				      função callback.

		3- console.log('Cadastrado com sucesso!'): 
				Mensagem de sucesso.
	
		4- req.session.sucess = true: Altera para TRUE o
					      valor da 
					      propriedade da 
					      sessão '.sucess'.

		5- return res.redirect('/'): Redireciona para a
					     pagina principal '/'.

		6- .catch((err)=>{...}): SE DER ERRADO(then), e 
					 uma função callback com
					 o parametro 'err' para
					 capturar o ERRO.

		7- console.log('Ops...Houve algum erro: '+ err):
				Mensagem de fracasso e mostra o 
				ERRO. 




PARA PUXAR INFORMAÇÕES DO BANCO DE DADOS:

NA ROTA ONDE VOCÊ QUER MOSTRAR OS VALORES...
Neste caso queremos mostrar os valores do banco de dados no pagina
'/users'.


1- ENCONTRE os valores da tabela usando .findAll():

   - Usuario.findAll().then(()=> {...}).catch((err)=>{...})

	* Usuario.findAll(): Metodo do Sequelize que encontra 
			     todos os VALORES existentes
			     na tabela do Banco de dados.

	* .then(()=>{}): SE DER CERTO...CALLBACK.

	* .catch((err)=>{}): SE DER ERRADO...CALLBACK.


2- VERIFIQUE SE OS VALORES EXISTEM OU NÃO:

	- Usuario.findAll().then((valores)=> {
        	if(valores.length > 0) {
            		return res.render('users', {
			table: true, usuarios: valores.map(
			valores => valores.toJSON())});
         	}
         	else {
            	res.render('users', {table: false});
        	};

	  }).catch((err)=> {
        	console.log(`Houve algum problema: ${err}`)
   	  });

	EXPLICAÇÃO POR LINHA:

	1- Usuario.findAll().then((valores)=> {}):

		- Usuario.findAll(): Encontra os valores da tabela
				     no banco de dados.

		- .then((valores)=>{}): Função callback, com o 
					parametro 'valores', que
					captura todos os dados que
					foram encontrados em um 
					ARRAY.

	2- if(valores.length > 0) {}: 
		
		- Se o cumprimento(.length) de 'valores' for maior 
		  que 0... SE EXISTIR VALORES...

	3- return res.render('users', {table: true, usuarios: 
	   valores.map(valores => valores.toJSON())}):

		- return res.render('users',{...}):
			RETORNA e RENDERIZA(.render) a pagina
			'/users', e um objeto{} com propriedades a
			serem usados pelo HANDDLEBARS.

		- 'users': Pagina '/users'.

		-  table: true : Propriedade 'table' recebe o 
				 valor TRUE. Esta propriedade
				 vai indicar ao HANDDLEBARS que
				 a TABELA EXISTE.

		- usuarios: valores.map(valores=>valores.toJSON())
			A propriedade 'usuarios' recebe 'valores'.
		
			* valores.map(): Mapeia os valores do 
					 array 'valores'. E aplica
					 a função passada como
					 parametro em CADA objeto
					 do array 'valores'.

			* valores=>valores.toJSON(): 
				Cria um NOVO array contendo os
				valores do array 'valores', e
				transforma-os para JSON(.toJSON).

		OBS.: TRANSFORMAR OS OBJETOS DO ARRAY 'VALORES' EM
		      'JSON' FACILITA A MANIPULAÇÃO COM O 
		      HANDDLEBARS.

	4- else{}: SE NÃO...

	5- res.render('users', {table: false}):
	
		- return res.render('users',{...}):
			RETORNA e RENDERIZA(.render) a pagina
			'/users', e um objeto{} com propriedades a
			serem usados pelo HANDDLEBARS.

		- 'users': Pagina '/users'.

		-  table: false : Propriedade 'table' recebe o 
				  valor FALSE. Esta propriedade
				  vai indicar ao HANDDLEBARS que
				  a TABELA NÃO EXISTE. 

	6- .catch((err)=> {}): SE DER ERRADO...CALLBACK.




PARA MOSTRAR OS VALORES CAPTURADOS NA TELA:

Com os OBJETOS{} e suas propriedades a ser usadas pelo HANDDLEBARS
vamos verificar se a TABELA EXITE OU NÃO e MOSTRAR NA TELA.
NA PAGINA ONDE VOCÊ QUER MOSTRAR OS VALORES...
Neste caso queremos mostrar os valores do banco de dados no pagina
'users.hbs'.


1- No ARQUIVO 'users.hbs', vamos verificar se a tabela existe.

	- {{#if table}}
	  <table>
	  ...
	  </table>
	  {{/if}}

		* {{#if table}}: SE a propriedade 'table' for TRUE.
				 Vai mostrar a <table>.

		* {{/if}}: Fecha o if.

	OBS.: Abra se IF ANTES da tag <table> e FECHE após a tag
	      </table>.


2- Crie uma condição caso a propriedade 'table' for FALSE.

	- {{#if table}}
	  <table>
	  ...
	  </table>
	  {{else}}
	  <div>
      	     Nenhum dado encontrado!
    	  </div>
	  {{/if}}

		* {{else}}: SE NÃO...VAI MOSTRAR A <div>.

	OBS.: NÃO é necessário FECHAR o 'else', somente o 'if'.


3- Vamos pegar a tag <tr>(colunas da table) no 
   <tbody>(corpo da table) e criar uma estrutura de repetição
   EACH:

	- {{#each usuarios}}
	  <tr>
	  ...
	  </tr>
	  {{/each}}

		* {{#each usuarios}}: Vai repetir as colunas de 
				      acordo com o comprimento do
				      array contido na
				      propriedade 'usuários'.

		* {{/each}}: Fecha o EACH.


4- INDICAR os valores a serem mostrados nas colunas:

	 - {{#each usuarios}}
      	   <tr>
        	<th>{{id}}</th>
        	<td>{{nome}}</td>
        	<td>{{email}}</td>
	   </tr>
	   {{/each}}

	EXPLICAÇÃO POR LINHA:

		1- <th>{{id}}</th>: Na tag <th> vai mostrar a
				    propriedade 'id' de dentro
				    do objeto{} do indice[0]
				    do array contido dentro
				    de 'usuarios'.

		2- <td>{{nome}}</td>: Na tag <td> vai mostrar a
				      propriedade 'nome' de dentro
				      do objeto{} do 
				      indice[0] do array contido 
				      dentro de 'usuarios'.


		3- <td>{{email}}</td>: Na tag <td> vai mostrar a
				       propriedade 'email' de 
				       dentro do objeto{} do 
				       indice[0] do array 
				       contido dentro de 
				       'usuarios'.

	OBS.: O INDICE SERÁ INCREMENTADO toda vez que o 'each'
	      repetir, de acordo com o comprimento do array 
	      contido em 'usuarios'.




EDITAR/ATUALIZAR DADOS DO BANCO DE DADOS:

No arquivo 'users.hbs', onde está o BOTÃO de EDITAR, vamos 
fazer algumas alterações para que este botão envie um formulário 
para A ROTA DE EDIÇÃO(/editar) com o valor do ID da tabela
que queremos EDITAR.

1- No arquivo(users.hbs) na <div> do botão que REDIRECIONA para
a pagina de edição. Que no caso é 'editar.hbs'. Vamos criar um 
<form> que APONTA para a ROTA '/editar':

	- <form action="/editar" method="post">...</form>
	       
		* action: Para APONTAR para a rota da pagina de
			  EDIÇÃO '/editar'.

		* method='post': Para ENVIAR o formulário.


2- Crie um INPUT OCULTO que receba o valor do ID da tabela(item)
   em que o botão se encontra. 

	- <form action="/editar" method="post">
                  <input type="hidden" name="id" value="{{id}}">
          </form>

		* type="hidden": Para que o INPUT fique 
		  OCULTO(hidden).

		* name="id": O NOME, que por meio dele é feita a
 			     manipulação com JS.

		* value="{{id}}": É o valor, que recebe o ID
				  da tabela(item) da qual ele 
				  pertence.


3- Coloque o <button>(botão) dentro do <form>(formulário), para 
   que ele DISPARE o envio do formulário para ROTA '/editar'.

	- <form action="/editar" method="post">
                  <input type="hidden" name="id" value="{{id}}">
		  <button class="w-100 btn">Editar</button>
          </form>

	OBS.: É OBRIGATÓRIO que seja um <button>. Qualquer outro
	      tipo de tag não vai disparar o envio do formulário. 


4- NO CODIGO PRINCIPAL(index.js), na ROTA '/editar', vamos alterar
   o tipo de rota de '.get' para POST:

	-  app.post('/editar', (req, res)=> {...})

		* ERA '.get'(pegar), AGORA É '.post'(enviar).


5- Vamos criar a variável que vai receber o valor do INPUT oculto
   que contém o ID da tabela(item) que queremos EDITAR.

	-  app.post('/editar', (req, res)=> {
    		let id = req.body.id;
	   });

		* let id = req.body.id:

			- req.body: É usado para acessar dados 
				    enviados do formulário.

			- .id: É o atributo 'name' do <input>.


6- FAZER CONSULTA da tabela(item) correspondente ao 'id' enviado 
   pelo <form>. Utilzando o método do SEQUELIZE '.findByPk()':

	- Usuario.findByPk(id).then(...).catch(...);

		* Usuario.findByPk(id): 

			- Usuario: Representa a TABELA(com os 
				   métodos do Sequelize).

			- .findByPk(id): Encontre(find) pela(by)
					 Chave-Primaria(Pk).
					 E a variavel 'id' como
					 argumento. Pois o ID é a
					 chave-primaria da nossa 
					 tabela.

		* .then(...): Se der CERTO...CALLBACK.

		* .catch(...): Se der ERRADO...CALLBACK.


7- O que acontece se der CERTO e ERRADO:

    SE DER CERTO:
	
	- Usuario.findByPk(id).then((dados)=> {
        	return res.render('editar', {error: false, 
		id: dados.id, nome: dados.nome, 
		email: dados.email});
    	  }).catch(...);

	EXPLICAÇÃO POR LINHA:
	
		1- .then((dados)=>{}): Se der CERTO(then), e a 
				      função callback, que recebe
				      como argumento 'dados', que
				      são os DADOS DA TABELA 
				      correnpondente ao 'id'.

		       OBS.: Os DADOS SEMPRE vem como um OBJETO{}.

		2- return res.render('editar', {...}):
			RETORNA(return) e como RESPOSTA(res) 
			RENDERIZA(.render):

				- 'editar': A pagina '/editar'.

				- {...}: É um objeto{} com 
					 propriedades a serem 
					 usados pelo HANDDLEBARS.

		3- {error: false, id: dados.id, nome: dados.nome, 
		   email: dados.email}: 

			- error: false : Propriedade 'error' 
					 recebe FALSE, para 
					 representar que NÃO houve
					 ERROS.
			
			- id: dados.id : Propriedade 'id' recebe o
					 valor da propriedade 'id'
					 do objeto contido dentro
					 de 'dados'.

			- nome: dados.nome : Propriedade 'nome' 
					     recebe o valor da 
					     propriedade 'nome'
					     do objeto contido 
					     dentro de 'dados'.

			- email: dados.email : Propriedade 'email' 
					       recebe o valor da 
					       propriedade 'email'
					       do objeto contido 
					       dentro de 'dados'.


    SE DER ERRADO:

	- Usuario.findByPk(id).then(...
	  ).catch((err)=> {
        	console.log(err);
        	return res.render('editar', {error: true, 
		problema: 'Não é possivel EDITAR este registro!'});
    	  });

	EXPLICAÇÃO POR LINHA:
		
		1- .catch((err)=> {...}): Se der ERRADO(catch) e a
					  função callback, com o 
					  'err' como argumento.
					  'err' captura o ERRO que
					  aconteceu.

		2- console.log(err): Mensagem para mostrar o ERRO.

		3- return res.render('editar', {...}):
			RETORNA(return) e como RESPOSTA(res) 
			RENDERIZA(.render):

				- 'editar': Pagina '/editar'.

				- {...}: É um objeto{} com 
					 propriedades a serem 
					 usados pelo HANDDLEBARS.

		4- {error: true, problema: 'Não é possivel...'}:
			
			- error: true : Propriedade 'error' recebe
					TRUE, para representar que
					HOUVERAM ERROS.

			- problema: '...': Propriedade 'problema'
					   recebe uma string ('').
					   Que será a mensagem a 
					   ser mostrada ao usuario.


8- VALIDAÇÃO se NÃO houver ERRO na página 'editar.hbs'.
   Utilizando o #unless:

	- {{#unless error}}
	  <form>
	   ...
	  </form>
	  {{/unless}}

		* {{unless error}}: SE 'error' for FALSE...

   OBS.: {{#unless}}: Funciona como o INVERSO do IF. Seu bloco 
		      será renderizado se a expressão retornar 
		      um valor FALSO.

				    
9- VALIDAÇÃO se HOUVER ERRO na página 'editar.hbs' com {{else}}:

	-  {{#unless error}}
	  <form>
	   ...
	  </form>
	  {{else}}
	  <div>
	     Houve um problema: {{problema}}
	  </div>
	  {{/unless}}

		* {{else}}: Se 'error' for TRUE...
			    Vai mostrar uma mensagem, e a 
			    propriedade 'problema'.

	OBS.: O {{else}} não é necessário ser fechado, e ele fica 
	      DENTRO da estrutura de condição {{#unless}}.

	


BOOTSRAP

PARA IMPORTAR O CSS E O SCRIPT DO BOOTSTRAP é só ir no site oficial
getbootsrap.com  copiar e colar os links do CDN no seu arquivo 
'main.hbs'. 